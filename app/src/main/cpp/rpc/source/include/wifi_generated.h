// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WIFI_WIFI_H_
#define FLATBUFFERS_GENERATED_WIFI_WIFI_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace wifi {

struct HostapdInfo;
struct HostapdInfoBuilder;

struct HostapdInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HostapdInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOSTAPD_SSID = 4,
    VT_HOSTAPD_PASSPHRASE = 6,
    VT_HOSTAPD_CHANNEL = 8,
    VT_HOSTAPD_IP_ADDRESS_V6 = 10,
    VT_HOSTAPD_SECURITY_TYPE = 12
  };
  const ::flatbuffers::String *hostapd_ssid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOSTAPD_SSID);
  }
  const ::flatbuffers::String *hostapd_passphrase() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOSTAPD_PASSPHRASE);
  }
  int32_t hostapd_channel() const {
    return GetField<int32_t>(VT_HOSTAPD_CHANNEL, 0);
  }
  const ::flatbuffers::String *hostapd_ip_address_v6() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOSTAPD_IP_ADDRESS_V6);
  }
  int32_t hostapd_security_type() const {
    return GetField<int32_t>(VT_HOSTAPD_SECURITY_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HOSTAPD_SSID) &&
           verifier.VerifyString(hostapd_ssid()) &&
           VerifyOffset(verifier, VT_HOSTAPD_PASSPHRASE) &&
           verifier.VerifyString(hostapd_passphrase()) &&
           VerifyField<int32_t>(verifier, VT_HOSTAPD_CHANNEL, 4) &&
           VerifyOffset(verifier, VT_HOSTAPD_IP_ADDRESS_V6) &&
           verifier.VerifyString(hostapd_ip_address_v6()) &&
           VerifyField<int32_t>(verifier, VT_HOSTAPD_SECURITY_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct HostapdInfoBuilder {
  typedef HostapdInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hostapd_ssid(::flatbuffers::Offset<::flatbuffers::String> hostapd_ssid) {
    fbb_.AddOffset(HostapdInfo::VT_HOSTAPD_SSID, hostapd_ssid);
  }
  void add_hostapd_passphrase(::flatbuffers::Offset<::flatbuffers::String> hostapd_passphrase) {
    fbb_.AddOffset(HostapdInfo::VT_HOSTAPD_PASSPHRASE, hostapd_passphrase);
  }
  void add_hostapd_channel(int32_t hostapd_channel) {
    fbb_.AddElement<int32_t>(HostapdInfo::VT_HOSTAPD_CHANNEL, hostapd_channel, 0);
  }
  void add_hostapd_ip_address_v6(::flatbuffers::Offset<::flatbuffers::String> hostapd_ip_address_v6) {
    fbb_.AddOffset(HostapdInfo::VT_HOSTAPD_IP_ADDRESS_V6, hostapd_ip_address_v6);
  }
  void add_hostapd_security_type(int32_t hostapd_security_type) {
    fbb_.AddElement<int32_t>(HostapdInfo::VT_HOSTAPD_SECURITY_TYPE, hostapd_security_type, 0);
  }
  explicit HostapdInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HostapdInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HostapdInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HostapdInfo> CreateHostapdInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> hostapd_ssid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hostapd_passphrase = 0,
    int32_t hostapd_channel = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hostapd_ip_address_v6 = 0,
    int32_t hostapd_security_type = 0) {
  HostapdInfoBuilder builder_(_fbb);
  builder_.add_hostapd_security_type(hostapd_security_type);
  builder_.add_hostapd_ip_address_v6(hostapd_ip_address_v6);
  builder_.add_hostapd_channel(hostapd_channel);
  builder_.add_hostapd_passphrase(hostapd_passphrase);
  builder_.add_hostapd_ssid(hostapd_ssid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HostapdInfo> CreateHostapdInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *hostapd_ssid = nullptr,
    const char *hostapd_passphrase = nullptr,
    int32_t hostapd_channel = 0,
    const char *hostapd_ip_address_v6 = nullptr,
    int32_t hostapd_security_type = 0) {
  auto hostapd_ssid__ = hostapd_ssid ? _fbb.CreateString(hostapd_ssid) : 0;
  auto hostapd_passphrase__ = hostapd_passphrase ? _fbb.CreateString(hostapd_passphrase) : 0;
  auto hostapd_ip_address_v6__ = hostapd_ip_address_v6 ? _fbb.CreateString(hostapd_ip_address_v6) : 0;
  return wifi::CreateHostapdInfo(
      _fbb,
      hostapd_ssid__,
      hostapd_passphrase__,
      hostapd_channel,
      hostapd_ip_address_v6__,
      hostapd_security_type);
}

}  // namespace wifi

#endif  // FLATBUFFERS_GENERATED_WIFI_WIFI_H_
